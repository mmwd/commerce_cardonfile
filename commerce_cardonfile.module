<?php

/**
 * @file
 * Supports card on file functionality for credit card payment methods by
 * associating card data reference IDs from payment gateways with user accounts.
 */

// -----------------------------------------------------------------------
// Constants

// Card on file process status codes
define('COMMERCE_COF_PROCESS_CODE_INSUFFICIENT_DATA', 'insufficient');
define('COMMERCE_COF_PROCESS_CODE_CARD_NA', 'card_na');
define('COMMERCE_COF_PROCESS_CODE_CARD_EXPIRED', 'card_expired');
define('COMMERCE_COF_PROCESS_CODE_CARD_NOT_CHARGEABLE', 'card_not_chargeable');
define('COMMERCE_COF_PROCESS_CODE_METHOD_EMPTY', 'no_method');
define('COMMERCE_COF_PROCESS_CODE_METHOD_NOT_CAPABLE', 'method_not_capable');
define('COMMERCE_COF_PROCESS_CODE_METHOD_FAILURE', 'method_failure');
define('COMMERCE_COF_PROCESS_CODE_METHOD_SUCCESS', 'method_success');


// -----------------------------------------------------------------------
// Includes
require_once dirname(__FILE__) . '/commerce_cardonfile.field.inc';


/**
 * Implements hook_menu().
 */
function commerce_cardonfile_menu() {
  $items = array();

  $items['admin/commerce/config/cardonfile'] = array(
    'title' => 'Card on file settings',
    'description' => 'Configure your card on file settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_cardonfile_settings_form'),
    'access arguments' => array('configure cardonfile'),
    'file' => 'includes/commerce_cardonfile.admin.inc',
  );

  $items['user/%user/stored-payment-methods/%commerce_cardonfile_data'] = array(
    'title' => 'Credit card',
    'page callback' => 'commerce_cardonfile_redirect_to_user',
    'page arguments' => array(1),
    'access callback' => 'commerce_cardonfile_data_access',
    'access arguments' => array('view', 3),
  );

  $items['user/%user/stored-payment-methods/%commerce_cardonfile_data/update'] = array(
    'title' => 'Update',
    'description' => 'Update a stored payment method.',
    'page callback' => 'commerce_cardonfile_update_page',
    'page arguments' => array(3, 1),
    'access callback' => 'commerce_cardonfile_data_access',
    'access arguments' => array('edit', 3, 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 0,
    'file' => 'includes/commerce_cardonfile.pages.inc',
  );

  $items['user/%user/stored-payment-methods/%commerce_cardonfile_data/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete a stored payment method.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_cardonfile_delete_form', 3),
    'access callback' => 'commerce_cardonfile_data_access',
    'access arguments' => array('delete', 3, 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 5,
    'file' => 'includes/commerce_cardonfile.pages.inc',
  );

  $items['user/%user/stored-payment-methods/%commerce_cardonfile_data/%/toggle-default'] = array(
    'title' => 'Set default',
    'title callback' => 'commerce_cardonfile_data_toggle_default_card_callback_title',
    'title arguments' => array(3),
    'description' => 'Toggle the default flag for a stored payment method.',
    'page callback' => 'commerce_cardonfile_data_toggle_default_card_callback',
    'page arguments' => array(3, 1, 4),
    'access callback' => 'commerce_cardonfile_data_toggle_default_card_callback_access',
    'access arguments' => array(3, 1, 4),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 20,
  );

  // create paths for each payment method
  $create_implements = commerce_cardonfile_payment_method_implements('create callback');
  foreach ($create_implements as $method_id => $method_function) {
    $payment_method_instances = _commerce_cardonfile_payment_method_instances($method_id, TRUE);
    if (empty($payment_method_instances)) {
      continue;
    }

    foreach ($payment_method_instances as $instance_id => $payment_method) {
      $new_card_data = commerce_cardonfile_data_new(array(
        'instance_id' => $instance_id,
        'payment_method' => $payment_method['method_id'],
      ));
      $items['user/%user/stored-payment-methods/add/' . drupal_hash_base64($instance_id)] = array(
        'title' => 'Add a !name',
        'title arguments' => array('!name' => $payment_method['display_title']),
        'page callback' => 'commerce_cardonfile_create_page',
        'page arguments' => array($new_card_data, 1),
        'access callback' => 'commerce_cardonfile_data_access',
        'access arguments' => array('create', $new_card_data, 1),
        'type' => MENU_LOCAL_ACTION,
        'file' => 'includes/commerce_cardonfile.pages.inc',
      );
    }
  }


  return $items;
}

/**
 * Redirects to the user's stored payment methods page.
 */
function commerce_cardonfile_redirect_to_user($account) {
  drupal_goto('user/' . $account->uid . '/stored-payment-methods');
}

/**
 * Implements hook_permission().
 */
function commerce_cardonfile_permission() {
  return array(
    'configure cardonfile' => array(
      'title' => t('Configure Card on File'),
      'description' => t('Update the Card on File configuration in the Store back end.'),
      'restrict access' => TRUE,
    ),
    'administer card data' => array(
      'title' => t('Administer card data'),
      'description' => t("Access and update any user's stored card data."),
      'restrict access' => TRUE,
    ),
    'view any card data' => array(
      'title' => t('View any card data'),
      'restrict access' => TRUE,
    ),
    'view own card data' => array(
      'title' => t('View own card data'),
    ),
    'create any card data' => array(
      'title' => t('Create any card data'),
      'restrict access' => TRUE,
    ),
    'create own card data' => array(
      'title' => t('Create own card data'),
    ),
    'edit any card data' => array(
      'title' => t('Edit any card data'),
      'restrict access' => TRUE,
    ),
    'edit own card data' => array(
      'title' => t('Edit own card data'),
    ),
    'delete any card data' => array(
      'title' => t('Delete any card data'),
      'restrict access' => TRUE,
    ),
    'delete own card data' => array(
      'title' => t('Delete own card data'),
    ),
  );
}

/**
 * Implements hook_hook_info().
 */
function commerce_cardonfile_hook_info() {
  $base_info = array(
    'group' => 'commerce',
  );

  $hooks = array(
    'commerce_cardonfile_data_insert' => $base_info,
    'commerce_cardonfile_data_update' => $base_info,
    'commerce_cardonfile_data_disable' => $base_info,
    'commerce_cardonfile_data_delete' => $base_info,
    'commerce_cardonfile_data_can_delete' => $base_info,
    'commerce_cardonfile_order_chargeable_cards' => $base_info,
    'commerce_cardonfile_checkout_pane_form_alter' => $base_info,
  );

  return $hooks;
}

/**
 * Implements hook_views_api().
 */
function commerce_cardonfile_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_cardonfile') . '/includes/views',
  );
}

/**
 * Implements hook_enable().
 */
function commerce_cardonfile_enable() {
  commerce_cardonfile_configure_order_type();
}

/**
 * Implements hook_modules_enabled().
 *
 * - Ensure order fields for newly enabled modules
 */
function commerce_cardonfile_modules_enabled($modules) {
  $possible_modules = module_implements('entity_info_alter');
  $enabled_possible_modules = array_intersect($modules, $possible_modules);

  // configure fields if any enabled module could register a new order bundle
  if (!empty($enabled_possible_modules)) {
    entity_info_cache_clear();
    commerce_cardonfile_configure_order_type();
  }
}


// -----------------------------------------------------------------------
// Theme

/**
 * Implements hook_theme().
 */
function commerce_cardonfile_theme() {
  return array(
    'card_data_overview' => array(
      'variables' => array('card_data' => array()),
    ),
    'commerce_cardonfile_data_label' => array(
      'variables' => array('card_data' => array()),
    ),
  );
}

/**
 * Themes a display of stored card data.
 *
 * @param $variables
 *   An array of theme variables including:
 *   - card_data: a data array for the stored card on file
 */
function theme_card_data_overview($variables) {
  drupal_add_css(drupal_get_path('module', 'commerce_cardonfile') . '/theme/commerce_cardonfile.css');
  $card_data = $variables['card_data'];

  // Load the credit card helper functions from the Payment module.
  commerce_cardonfile_load_credit_card_helpers();
  $card_types = commerce_payment_credit_card_types();

  // Extract the name of the card type if possible.
  $card_type = t('Credit card');

  if (!empty($card_types[$card_data['card_type']])) {
    $card_type = $card_types[$card_data['card_type']];
  }

  // Build an array of data lines to include in the overview.
  $lines = array(
    t('Type:') => $card_type,
    t('Cardholder name:') => check_plain($card_data['card_name']),
    t('Number (last 4):') => '******' . check_plain($card_data['card_number']),
    t('Expiration date:') => check_plain($card_data['card_exp_month'] . '/' . $card_data['card_exp_year']),
    t('Stored status:') => !empty($card_data['status']) ? t('Active') : t('Disabled'),
  );

  $output = '';

  foreach ($lines as $label => $value) {
    // Only add a line if it has a value.
    if (!empty($value)) {
      $output .= '<div class="commerce-card-data-line"><span class="label">' . $label . '</span> ' . $value . '</div>';
    }
  }

  return '<div class="commerce-card-data">' . $output . '</div>';
}

// -----------------------------------------------------------------------
// Field setup

/**
 * Ensures the card on file field is present on a specific order bundle.
 *
 * @param $bundle
 *   The order bundle to configure. If not provided, then all bundles are
 *   configured.
 */
function commerce_cardonfile_configure_order_type($bundle = NULL) {
  $bundles = array();
  if (!empty($bundle)) {
    $bundles[] = $bundle;
  }
  elseif ($bundle_names = commerce_order_type_get_name()) {
    $bundles = array_keys($bundle_names);
  }

  // Exit if no types to configure
  if (empty($bundles)) {
    return;
  }

  // intialize field variables
  $field_type = 'commerce_cardonfile_reference';
  $field_name = 'commerce_cardonfile';

  // If a field type we know should exist isn't found, clear the Field cache.
  if (!field_info_field_types($field_type)) {
    field_cache_clear();
  }

  // get field type information for defaults
  $field_type_info = field_info_field_types($field_type);

  // determine defaults
  $default_widget = !empty($field_type_info['default_widget']) ? $field_type_info['default_widget'] : 'options_select';
  $default_formatter = !empty($field_type_info['default_formatter']) ? $field_type_info['default_formatter'] : 'commerce_cardonfile_reference_label_link';

  // Configure the field
  $field = field_info_field($field_name);
  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => $field_type,
      'cardinality' => 1,
      'entity_types' => array('commerce_order'),
      'translatable' => FALSE,
      'locked' => TRUE,
    );
    $field = field_create_field($field);
  }

  // configure field instances for each bundle
  foreach ($bundles as $bundle) {
    $instance = field_info_instance('commerce_order', $field_name, $bundle);
    if (!empty($instance)) {
      continue;
    }

    $instance = array(
      'field_name' => $field_name,
      'entity_type' => 'commerce_order',
      'bundle' => $bundle,
      'label' => t('Card on file Processed'),
      'settings' => array(),
      'widget' => array(
        'type' => $default_widget,
        'weight' => 10,
      ),
      'display' => array(),
    );

    // Set the default display formatters for various view modes.
    foreach (array('default', 'customer', 'administrator') as $view_mode) {
      $instance['display'][$view_mode] = array(
        'label' => 'above',
        'type' => $default_formatter,
        'weight' => 10,
      );
    }

    field_create_instance($instance);
  }
}


// -----------------------------------------------------------------------
// Checkout

/**
 * Implements hook_form_alter().
 *
 * This implementation alters any checkout form looking for the payment pane
 * and seeing if its details are currently for a credit card payment method. If
 * so, it adds the necessary form elements for Card on File payment, including a
 * select element to use previously stored credit card information and a
 * checkbox on the credit card data entry form to store the given credit card on
 * file for future usage.
 */
function commerce_cardonfile_form_alter(&$form, &$form_state, $form_id) {
  // Exit if the current form ID is for a checkout page form...
  if (strpos($form_id, 'commerce_checkout_form_') !== 0 ||
      !commerce_checkout_page_load(substr($form_id, 23))) {
    return;
  }

  // Exit if the current page's form does no include the payment checkout pane...
  if (empty($form['commerce_payment'])) {
    return;
  }

  // DENY if user is not defined or is anonymous
  if (!isset($form_state['account']) || empty($form_state['account']->uid)) {
    return;
  }

  // Exit if no payment method instance id
  if (empty($form['commerce_payment']['payment_method']['#default_value'])) {
    return;
  }

  // Exit if not a credit card based payment method
  if (empty($form['commerce_payment']['payment_details']['credit_card'])) {
    return;
  }

  // Extact payment method instance id
  $instance_id = $form['commerce_payment']['payment_method']['#default_value'];

  // Check to see if the currently selected payment method is Card on File
  // enabled (via the cardonfile boolean in its info array).
  $payment_method = commerce_payment_method_instance_load($instance_id);

  // Exit if payment method is not capable of card on file
  if (!_commerce_cardonfile_capable_payment_method_check($payment_method)) {
    return;
  }

  // Add a checkbox to the credit card details container to store the
  // credit card for future use.
  $storage = variable_get('commerce_cardonfile_storage', 'opt-in');

  if (in_array($storage, array('opt-in', 'opt-out'))) {
    $form['commerce_payment']['payment_details']['credit_card']['cardonfile_store'] = array(
      '#type' => 'checkbox',
      '#title' => t('Store this credit card on file for future use.'),
      '#default_value' => $storage == 'opt-out',
    );
  }
  else {
    $form['commerce_payment']['payment_details']['credit_card']['cardonfile_store'] = array(
      '#type' => 'value',
      '#value' => TRUE,
    );
  }

  // Load existing active cards for the payment method instance and user.
  $stored_cards = commerce_cardonfile_data_load_multiple_by_id(array(), array(
    'uid' => $form_state['account']->uid,
    'instance_id' => $payment_method['instance_id'],
    'status' => 1,
  ));

  // Build options form
  $cardonfile_options_form = array();
  $instance_default_card_id = NULL;

  // If have stored cards ...
  if (!empty($stored_cards)) {
    $valid_cards = array_filter($stored_cards, 'commerce_cardonfile_data_check_expiration');

    // If have un-expired cards ...
    if (!empty($valid_cards)) {
      // get options list with labels
      $card_option_element_type = variable_get('commerce_cardonfile_selector', 'radios');
      $card_options = commerce_cardonfile_element_options_list($valid_cards, $card_option_element_type);

      // determine default option
      $card_options_default_value = key($card_options);
      foreach (array_keys($card_options) as $card_id) {
        if (isset($valid_cards[$card_id]) && !empty($valid_cards[$card_id]['instance_default'])) {
          $card_options_default_value = $instance_default_card_id = $card_id;

          // move instance default to the top of the list
          $card_option_label = $card_options[$card_id];
          unset($card_options[$card_id]);
          $card_options = array($card_id => $card_option_label) + $card_options;
          break;
        }
      }

      // create options element
      $cardonfile_options_form = array(
        '#type' => $card_option_element_type,
        '#title' => t('Select a stored credit card'),
        '#options' => $card_options,
        '#default_value' => $card_options_default_value,
        '#weight' => -10,
        '#ajax' => array(
          'callback' => 'commerce_payment_pane_checkout_form_details_refresh',
          'wrapper' => 'payment-details',
        ),
      );
    }
  }

  // update form with options
  if (!empty($cardonfile_options_form)) {
    $form['commerce_payment']['payment_details']['cardonfile'] = $cardonfile_options_form;

    // Add the CSS to hide a sole credit card icon if specified.
    if (variable_get('commerce_cardonfile_hide_cc_radio_button', TRUE)) {
      if (count($form['commerce_payment']['payment_method']['#options']) == 1) {
        $form['commerce_payment']['payment_method']['#attached']['css'][] = drupal_get_path('module', 'commerce_cardonfile') . '/theme/commerce_cardonfile.checkout.css';
      }
    }

    // If the current value for the card selection element is not to use
    // a different credit card, then hide the credit card form elements.
    if (empty($form_state['values']) || $form_state['values']['commerce_payment']['payment_details']['cardonfile'] !== 'new') {
      $form['commerce_payment']['payment_details']['credit_card']['#access'] = FALSE;
    }
  }
  else {
    $form['commerce_payment']['payment_details']['cardonfile'] = array(
      '#type' => 'value',
      '#value' => 'new',
    );
  }

  // Add mark as default element
  $instance_default_default_value = 0;
  if (!empty($instance_default_card_id)) {
    if (empty($form_state['values']) ||
      (!empty($form_state['values']['commerce_payment']['payment_details']['cardonfile']) &&
      $form_state['values']['commerce_payment']['payment_details']['cardonfile'] == $instance_default_card_id)) {
      $instance_default_default_value = 1;
    }
  }

  $force_instance_default = empty($stored_cards);
  $form['commerce_payment']['payment_details']['cardonfile_instance_default'] = array(
    '#type' => 'checkbox',
    '#title' => t('Set as your default card'),
    '#default_value' => $instance_default_default_value || $force_instance_default,
    '#access' => !$instance_default_default_value,
    '#disabled' => $force_instance_default,
    '#states' => array(
      'invisible' => array(
        ':input[name$="[cardonfile]"]' => array('value' => 'new'),
      ),
      'visible' => array(
        ':input[name$="[cardonfile_store]"]' => array('checked' => TRUE),
      ),
    ),
  );

  // Allow others to alter this alter
  drupal_alter('commerce_cardonfile_checkout_pane_form', $form['commerce_payment']['payment_details'], $form);

  // Add submit handler
  if (isset($form['buttons']['continue'])) {
    $form['buttons']['continue']['#submit'][] = 'commerce_cardonfile_commerce_checkout_form_submit';
  }
}

/**
 * Checkout form submit callback to process card on file options
 */
function commerce_cardonfile_commerce_checkout_form_submit($form, &$form_state) {
  if (!isset($form_state['order']) || empty($form_state['values']['commerce_payment'])) {
    return;
  }

  $pane_values = &$form_state['values']['commerce_payment'];
  $store_card = !empty($pane_values['payment_details']['credit_card']['cardonfile_store']);

  // Exit if no card selection
  if (empty($pane_values['payment_details']['cardonfile'])) {
    return;
  }

  // Load a fresh copy of the order stored in the form.
  $order = commerce_order_load($form_state['order']->order_id);
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  $account = $form_state['account'];
  $instance_id = $pane_values['payment_method'];

  // get card on file value
  $card_id_selected = NULL;
  if ($pane_values['payment_details']['cardonfile'] != 'new') {
    $card_id_selected = intval($pane_values['payment_details']['cardonfile']);
  }
  elseif ($store_card && ($cof_last_inserts = _commerce_cardonfile_data_current_request_last_inserted())) {
    // Assumes the new card is the current request's last inserted card that
    // matches the user
    foreach ($cof_last_inserts as $card_data) {
      if ($card_data['uid'] == $account->uid && $card_data['instance_id'] == $instance_id) {
        $card_id_selected = $card_data['card_id'];
        break;
      }
    }
  }

  // Submit actions for card selected
  if (!empty($card_id_selected)) {
    // Mark as default
    if (!empty($pane_values['payment_details']['cardonfile_instance_default'])) {
      commerce_cardonfile_data_set_default_card($card_id_selected);
    }

    // Save card id to the order reference field
    $order_wrapper->commerce_cardonfile = array('card_id' => $card_id_selected);
    $order_wrapper->save();
  }
}

/**
 * Returns an options array for selecting a card on file during checkout
 *
 * @param $stored_cards
 *   An array of stored card data arrays keyed by card_id.
 * @param $element_type
 *   The form element the options array will be for, 'radios' or 'select'.
 * @param $different
 *   Add an option to use a different credit card.
 *
 * @return
 *   An options array for selecting a card on file.
 */
function commerce_cardonfile_element_options_list($stored_cards, $element_type = 'radios', $different = TRUE) {
  // Build an options array of stored credit cards.
  $options = array();

  foreach ($stored_cards as $card_id => $card_data) {
    $options[$card_id] = theme('commerce_cardonfile_data_label', array('card_data' => $card_data));
  }

  // Add an option to use a different credit card if specified.
  if ($different) {
    $options['new'] = t('Use a different credit card');
  }

  return $options;
}


// -----------------------------------------------------------------------
// Payment method callback handling

/**
 * Returns an array of all available payment method cardonfile callbacks
 */
function commerce_cardonfile_payment_method_available_callbacks() {
  return array(
    'create callback',
    'update callback',
    'delete callback',
    'process callback',
    'get address callback',
    'charge callback', // (implemented in commerce_recurring)
  );
}

/**
 * Returns the Card on File callback function for the given payment method.
 *
 * @param $payment_method
 *   The payment method object.
 * @param $callback
 *   The callback function to return, one of:
 *    - 'create callback',
 *    - 'update callback'
 *    - 'delete callback'
 *    - 'process callback'
 *    - 'get address callback'
 *    - 'charge callback' (implemented in commerce_recurring)
 *
 * @return
 *   A string containing the name of the callback function or FALSE if it could
 *   not be found.
 */
function commerce_cardonfile_payment_method_callback($payment_method, $callback) {
  if (!empty($payment_method) && !empty($payment_method['method_id'])) {
    $implements = commerce_cardonfile_payment_method_implements($callback);
    if (!empty($implements) && !empty($implements[$payment_method['method_id']])) {
      return $implements[$payment_method['method_id']];
    }
  }
}

/**
 * Returns all payment method instances that implement a specific callback
 *
 * @param $callback
 *   The callback function to return, one of:
 *    - 'create callback',
 *    - 'update callback'
 *    - 'delete callback'
 *    - 'process callback'
 *    - 'get address callback'
 *    - 'charge callback' (implemented in commerce_recurring)
 *
 * @return
 *   An array of callback function names keyed by payment method id
 */
function commerce_cardonfile_payment_method_implements($callback) {
  $cache = &drupal_static(__FUNCTION__);

  if (!isset($cache)) {
    $cache = array();

    // get payment methods and load module implements for hook_commerce_payment_method_info()
    // so that cardonfile callback can be in same hook file, ie mymodule.commerce.inc
    $payment_methods = _commerce_cardonfile_capable_payment_methods();
    $available_callbacks = commerce_cardonfile_payment_method_available_callbacks();
    foreach ($payment_methods as $method_id => $payment_method) {
      foreach ($available_callbacks as $available_callback) {
        if (!empty($payment_method['cardonfile'][$available_callback])) {
          $func = $payment_method['cardonfile'][$available_callback];
          if (function_exists($func)) {
            $cache[$available_callback][$method_id] = $func;
          }
        }
      }
    }
  }

  return isset($cache[$callback]) ? $cache[$callback] : array();
}

/**
 * Returns all payment methods that are card on file capable
 *
 * @return
 *  An associative array of payment method objects keyed by the method_id.
 */
function _commerce_cardonfile_capable_payment_methods() {
  $capable_methods = array();
  $payment_methods = commerce_payment_methods();
  foreach ($payment_methods as $method_id => $payment_method) {
    if (_commerce_cardonfile_capable_payment_method_check($payment_method)) {
      $capable_methods[$method_id] = $payment_method;
    }
  }

  return $capable_methods;
}

/**
 * Returns TRUE if a payment method is capable of card on file
 *
 * @param $payment_method
 *   An associative array of payment method objects keyed by the method_id.
 *
 * @return
 *   TRUE if payment method is capable of card on file
 */
function _commerce_cardonfile_capable_payment_method_check($payment_method) {
  return !empty($payment_method['cardonfile']);
}

/**
 * Returns all payment method instances that are card on file capable
 *
 * @param $include_disabled
 *   Return enabled and disabled instances
 *
 * @return
 *   An associative array of payment method objects keyed by the instance_id.
 */
function _commerce_cardonfile_capable_payment_method_instances($include_disabled = FALSE) {
  $capable_instances = array();
  $payment_methods = _commerce_cardonfile_capable_payment_methods();
  foreach ($payment_methods as $method_id => $payment_method) {
    $method_instances = _commerce_cardonfile_payment_method_instances($method_id, $include_disabled);
    $capable_instances += $method_instances;
  }

  return $capable_instances;
}

/**
 * Returns all payment method instances for a given payment method id
 *
 * @param $method_id
 *   A payment method id
 * @param $include_disabled
 *   Return enabled and disabled instances
 *
 * @return
 *   An array of all loaded payment method instances keyed by instance_id
 */
function _commerce_cardonfile_payment_method_instances($method_id, $include_disabled = FALSE) {
  $cached_ids = &drupal_static(__FUNCTION__, array());
  $include_disabled = !empty($include_disabled);

  if (!array_key_exists($method_id, $cached_ids)) {
    $cached_ids[$method_id] = array();

    // load all rules ... no easier way
    $rules_configs = rules_config_load_multiple(FALSE);

    // find all rules with an action to enable this method
    foreach ($rules_configs as $rule_name => $rule) {
      // fast skip if rule does not depend on commerce_payment
      if (!isset($rule->dependencies) || !in_array('commerce_payment', $rule->dependencies)) {
        continue;
      }

      foreach ($rule->actions() as $action) {
        // skip any actions that are not simple rules actions, ie loops
        if (!($action instanceof RulesAction)) {
          continue;
        }

        if ($action->getElementName() == 'commerce_payment_enable_' . $method_id) {
          $instance_id = commerce_payment_method_instance_id($method_id, $rule);
          $cached_ids[$method_id][$instance_id] = $rule->active;
          continue 2; // skip to next rule
        }
      }
    }
  }

  // load instances
  $instances = array();
  if (!empty($cached_ids[$method_id])) {
    foreach ($cached_ids[$method_id] as $instance_id => $instance_active) {
      if ($instance_active || $include_disabled) {
        $instances[$instance_id] = commerce_payment_method_instance_load($instance_id);
      }
    }
  }

  return $instances;
}


// -----------------------------------------------------------------------
// Card data handling

/**
 * Returns a list of cof data statuses
 */
function commerce_cardonfile_data_statuses() {
  $statuses = array(
    0 => t('Disabled'),
    1 => t('Active'),
    2 => t('Not deletable'),
  );

  return $statuses;
}

/**
 * Returns the human readable title of any or all data statuses.
 *
 * @param $name
 *   Optional parameter specifying the name of the status whose title
 *     to return.
 *
 * @return
 *   Either an array of all status titles keyed by the status_id or a
 *     string containing the human readable title for the specified status. If a
 *     status is specified that does not exist, this function returns FALSE.
 */
function commerce_cardonfile_data_status_get_title($name = NULL) {
  $statuses = commerce_cardonfile_data_statuses();

  // Return a status title if specified and it exists.
  if (!empty($name)) {
    if (isset($statuses[$name])) {
      return $statuses[$name];
    }
    else {
      // Return FALSE if it does not exist.
      return FALSE;
    }
  }

  // Otherwise return all titles.
  return $statuses;
}

/**
 * Wraps commerce_cardonfile_status_get_title().
 */
function commerce_cardonfile_data_status_options_list() {
  return commerce_cardonfile_data_status_get_title();
}

/**
 * Define property info for line item Kiala Point records
 */
function commerce_cardonfile_data_property_info_callback() {
  return array(
    'card_id' => array(
      'label' => t('Card Data Unique ID'),
      'type' => 'integer',
    ),
    'uid' => array(
      'label' => t('Owner User ID'),
      'type' => 'integer',
    ),
    'owner' => array(
      'label' => t('Owner'),
      'type' => 'user',
      'description' => t('The card owner user object.'),
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'payment_method' => array(
      'label' => t('Payment Method ID'),
      'type' => 'text',
    ),
    'instance_id' => array(
      'label' => t('Payment Method Instance ID'),
      'type' => 'text',
      'description' => t('The instance id for the payment method instance rules configuration.'),
    ),
    'payment_method_instance' => array(
      'label' => t('Payment Method Instance'),
      'type' => 'struct',
      'description' => t('The loaded payment method instance info array.'),
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'rule_name' => array(
      'label' => t('Payment Method Instance Rule Name'),
      'type' => 'text',
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'rule_config' => array(
      'label' => t('Payment Method Instance Rule Config'),
      'type' => 'rules_config',
      'description' => t('The rules config object of the payment method instance.'),
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'remote_id' => array(
      'label' => t('Remote ID'),
      'type' => 'text',
    ),
    'card_type' => array(
      'label' => t('Card Type'),
      'type' => 'text',
    ),
    'card_name' => array(
      'label' => t('Name on the Card'),
      'type' => 'text',
    ),
    'card_number' => array(
      'label' => t('Card Number (last 4 digits)'),
      'type' => 'text',
    ),
    'card_exp_month' => array(
      'label' => t('Card Expiration Month'),
      'type' => 'integer',
    ),
    'card_exp_year' => array(
      'label' => t('Card Expiration Year'),
      'type' => 'integer',
    ),
    'card_exp_timestamp' => array(
      'label' => t('Card Expiration Timestamp'),
      'type' => 'date',
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'card_expired' => array(
      'label' => t('Card Expired'),
      'type' => 'boolean',
      'description' => t('TRUE if the card has expired.'),
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'status' => array(
      'label' => t('Status'),
      'type' => 'integer',
      'options list' => 'commerce_cardonfile_data_statuses',
    ),
    'can_charge' => array(
      'label' => t('Can Charge'),
      'type' => 'boolean',
      'description' => t('TRUE if the card can be charged.'),
      'getter callback' => 'commerce_cardonfile_data_property_get',
      'computed' => TRUE,
    ),
    'created' => array(
      'label' => t('Created Date'),
      'type' => 'date',
    ),
    'changed' => array(
      'label' => t('Changed Date'),
      'type' => 'date',
    ),
    'instance_default' => array(
      'label' => t('Instance Default'),
      'type' => 'boolean',
      'description' => t('TRUE if the card has been marked as the default for the payment method instance.'),
    ),
  );
}

/**
 * Card data properties getter callback
 */
function commerce_cardonfile_data_property_get($data, array $options, $name) {
  switch ($name) {
    case 'owner':
      return !empty($data['uid']) ? $data['uid'] : NULL;

    case 'payment_method_instance':
      if (!empty($data['instance_id'])) {
        return commerce_payment_method_instance_load($data['instance_id']);
      }
      break;

    case 'rule_name':
    case 'rule_config':
      if (empty($data['instance_id'])) {
        return;
      }
      $payment_method = commerce_payment_method_instance_load($data['instance_id']);
      if (empty($payment_method)) {
        return;
      }

      // Explode the method key into its component parts.
      list($method_id, $rule_name) = explode('|', $payment_method['instance_id']);

      // Return name only since config will auto load
      return $rule_name ? $rule_name : NULL;

    case 'card_expired':
      return !commerce_cardonfile_data_check_expiration($data);

    case 'card_exp_timestamp':
      return commerce_cardonfile_data_expiration_timestamp($data);

    case 'can_charge':
      return commerce_cardonfile_data_can_charge($data);
  }
}

/**
 * Determines if the current user has access to the account's stored payments.
 */
function commerce_cardonfile_user_access($account) {
  global $user;

  // Grant access for any user with administer permission.
  if (user_access('administer card data')) {
    return TRUE;
  }

  // create a stub data array for access checks
  $card_data_stub = commerce_cardonfile_data_new(array(
    'uid' => $account->uid,
  ));

  // DENY if the user DOES NOT have view access
  if (!commerce_cardonfile_data_access('view', $card_data_stub, $account)) {
    return FALSE;
  }

  // DENY if the user DOES NOT have create access AND NO cards on file
  if (!commerce_cardonfile_data_access('create', $card_data_stub, $account)) {
    // DENY if the user DOES NOT have any cards
    $stored_cards = commerce_cardonfile_data_load_multiple($account->uid);
    if (empty($stored_cards)) {
      return FALSE;
    }
  }

  // ALLOW by default
  return TRUE;
}

/**
 * Rules integration access callback.
 */
function commerce_cardonfile_data_rules_access($type, $name) {
  if ($type == 'event' || $type == 'condition') {
    return commerce_cardonfile_data_access('view');
  }
}

/**
 * Determines if the current user has access to perform an operation on the
 * given card data array.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'edit', 'update', 'manage',
 *   'create' or 'delete'.
 * @param $card_data
 *   The card data array
 * @param $owner
 *   The user account for the card owner
 *
 * @return
 *   TRUE if the current user has access
 */
function commerce_cardonfile_data_access($op = 'view', $card_data = array(), $owner = NULL) {
  global $user;

  // resolve operation
  if ($op == 'manage' || $op == 'update') {
    $op = 'edit';
  }

  // DENY if invalid operation
  if (!in_array($op, array('view', 'edit', 'create', 'delete'))) {
    return FALSE;
  }

  // resolve owner uid
  $owner_uid = NULL;
  if (!empty($card_data['uid'])) {
    $owner_uid = $card_data['uid'];
  }
  elseif (!empty($owner->uid)) {
    $owner_uid = $owner->uid;
  }

  // load payment method instance and rule
  $payment_method = array();
  $payment_rule = NULL;

  if (!empty($card_data['instance_id'])) {
    $payment_method = commerce_payment_method_instance_load($card_data['instance_id']);
    if (!empty($payment_method)) {
      // Explode the method key into its component parts.
      list($payment_method_id, $instance_rule_name) = explode('|', $payment_method['instance_id']);
      $payment_rule = rules_config_load($instance_rule_name);
    }
  }

  // DENY for operations that require a payment method callback
  if (empty($payment_method) && $op != 'view') {
    return FALSE;
  }

  // Operation specific access checks
  $op_callback = TRUE;
  switch ($op) {
    case 'edit':
      // set operation callback
      $op_callback = commerce_cardonfile_payment_method_callback($payment_method, 'update callback');
      break;

    case 'create':
      // set operation callback
      $op_callback = commerce_cardonfile_payment_method_callback($payment_method, 'create callback');

      // DENY if payment rule has been disabled
      if ($op_callback && !empty($payment_rule) && empty($payment_rule->active)) {
        return FALSE;
      }
      break;

    case 'delete':
      // set operation callback
      $op_callback = commerce_cardonfile_payment_method_callback($payment_method, 'delete callback');
      break;

    default:
      $op_callback = TRUE;
      break;
  }

  // DENY if callback does NOT exist for specific operations
  if (empty($op_callback)) {
    return FALSE;
  }

  // ALLOW access for any user with administer permission.
  if (user_access('administer card data') || user_access("$op any card data")) {
    return TRUE;
  }

  // ALLOW access for users with permission to manage their own card data.
  if (!empty($owner_uid)) {
    if (!empty($user->uid) && $user->uid == $owner_uid && user_access("$op own card data")) {
      return TRUE;
    }
  }

  // DENY by default
  return FALSE;
}

/**
 * Returns a label for the card data suitable for an options list
 */
function theme_commerce_cardonfile_data_label(&$vars) {
  $card_data = $vars['card_data'];
  $replacements = _commerce_cardonfile_data_card_replacements($card_data, '@');
  return t('@card_type ***@card_number, Expires @card_exp_month/@card_exp_year @instance_default', $replacements);
}

/**
 * Returns an array of replacements suitable for t() or format_string()
 */
function _commerce_cardonfile_data_card_replacements($card_data, $prefix = '@') {
  $replacement_keys = array(
    'card_id',
    'card_name',
    'card_type',
    'card_number',
    'card_exp_month',
    'card_exp_year',
    'status',
    'instance_id',
    'instance_default',
  );

  // Load the credit card helper functions from the Payment module.
  commerce_cardonfile_load_credit_card_helpers();
  $card_types = commerce_payment_credit_card_types();

  // ensure prefix
  if (empty($prefix) || !in_array($prefix, array('@', '%', '!'))) {
    $prefix = '@';
  }

    $replacements = array(
      '!default' => !empty($card_data['instance_default']) ? t('(default)') : '',
    );

  // Process card data
  $replacements = array();
  foreach ($replacement_keys as $key) {
    $value = '';
    if (isset($card_data[$key])) {
      switch ($key) {
        case 'card_exp_month':
          $value = str_pad($card_data[$key], 2, '0', STR_PAD_LEFT);
          break;

        case 'card_type':
          if (!empty($card_types[$card_data[$key]])) {
            $value = $card_types[$card_data[$key]];
          }
          else {
            $value = t('Card');
          }
          break;

        case 'instance_default':
          $value = !empty($card_data[$key]) ? t('(default card)') : '';
          break;

        default:
          $value = $card_data[$key];
          break;
      }
    }

    $replacements[$prefix . $key] = $value;
  }

  return $replacements;
}

/**
 * Returns an initialized card on file data array.
 *
 * @param $values
 *   An array of initial values for the data array.
 *
 * @return
 *   A card on file data array.
 */
function commerce_cardonfile_data_new($values = array()) {
  $data = array();

  // initialize with given values
  if (is_array($values)) {
    $data = $values;
  }

  // merge in defaults
  $data += array(
    'card_id' => NULL,
    'uid' => NULL,
    'payment_method' => '',
    'instance_id' => '',
    'remote_id' => '',
    'card_type' => '',
    'card_name' => '',
    'card_number' => '',
    'card_exp_month' => '',
    'card_exp_year' => '',
    'status' => 1,
    'instance_default' => 0,
  );

  return $data;
}

/**
 * Loads stored card data by ID.
 *
 * @param $card_id
 *   The local ID of the stored card data to load.
 *
 * @return
 *   An array containing the specified card data or FALSE if the specified card
 *   data does not exist.
 */
function commerce_cardonfile_data_load($card_id) {
  $cards = commerce_cardonfile_data_load_multiple_by_id(array($card_id));
  return !empty($cards) ? reset($cards) : FALSE;
}

/**
 * Loads stored card data for a user by payment method instance.
 *
 * @param $uid
 *   The user ID of the user whose card data should be loaded.
 * @param $instance_id
 *   The payment method instance ID to load card data for.
 * @param $active
 *   Boolean indicating whether or not to only return active card data; defaults
 *   to TRUE.
 *
 * @return
 *   An associative array of all applicable card data keyed by card_id or an
 *   empty array if no matching data exists.
 */
function commerce_cardonfile_data_load_multiple($uid, $instance_id = NULL, $active = TRUE) {
  $conditions = array('uid' => $uid);

  if (!empty($instance_id)) {
    $conditions['instance_id'] = $instance_id;
  }

  if (!empty($active)) {
    $conditions['status'] = 1;
  }

  return commerce_cardonfile_data_load_multiple_by_id(array(), $conditions);
}

/**
 * Loads multiple stored card data similar to entity_load().
 *
 * @see entity_load()
 *
 * @param $ids
 *   An array of card IDs.
 * @param $conditions
 *   An array of conditions to filter by on the
 *   {commerce_card_data} table in the form 'field' => $value.
 *
 * @return
 *   An array of data arrays indexed by card_id.
 */
function commerce_cardonfile_data_load_multiple_by_id($ids = array(), $conditions = array()) {
  $have_ids = !empty($ids) && is_array($ids);
  $have_conditions = !empty($conditions);

  // exit if nothing to query
  if (!$have_ids && !$have_conditions) {
    return array();
  }

  // initialize query ids to ids given
  $query_ids = $have_ids ? $ids : array();

  // initialize query
  $records = array();
  $query = db_select('commerce_card_data', 'ccd')->fields('ccd');

  // add condition for ids
  if (!empty($query_ids)) {
    $query->condition('ccd.card_id', $query_ids, 'IN');
  }

  // Add given conditions
  if ($have_conditions) {
    $schema = drupal_get_schema('commerce_card_data');
    foreach ($conditions as $field => $field_value) {
      if (isset($schema['fields'][$field])) {
        // skip if an empty array
        if (is_array($field_value) && empty($field_value)) {
          continue;
        }

        // add condition
        $query->condition('ccd.' . $field, $field_value);
      }
    }
  }

  // Order by card_id descending to show latest at the top
  $query->orderBy('card_id', 'DESC');

  // Execute query
  $result = $query->execute();
  $records = $result->fetchAllAssoc('card_id', PDO::FETCH_ASSOC);

  return $records;
}

/**
 * Saves an array of card data.
 *
 * @param $card_data
 *   An array of card data including the following keys:
 *   - card_id: if present, saves an existing card data array, otherwise inserts
 *     the card data in a new record
 *   - uid: the user ID of the account the card data is being stored for
 *   - payment_method: the name of the payment method the card was used for
 *   - instance_id: the payment method instance ID containing the credentials
 *     that will be used to reuse the card on file
 *   - remote_id: the remote ID to the full card data at the payment gateway
 *   - card_type: short name of the credit card type if determined, based on the
 *     keys returned by commerce_payment_credit_card_types()
 *   - card_name: the name of the cardholder
 *   - card_number: the last 4 digits of the credit card number
 *   - card_exp_month: the numeric representation of the expiration month
 *   - card_exp_year: the four digit expiration year
 *   - status: integer status of the card data: inactive (0), active (1), or
 *     active and not deletable (2).
 *
 * @return
 *   The operation performed by drupal_write_record() on save; since the card
 *   data array is received by reference, it will contain the serial numeric
 *   card_id used to represent the card data locally after an insert.
 */
function commerce_cardonfile_data_save(&$card_data) {
  $return = FALSE;
  $card_data_original = NULL;

  // Preprocess before saving and sending to hooks
  if (!empty($card_data['card_number'])) {
    // Always truncate card for security before passing to hooks
    $card_data['card_number'] = substr($card_data['card_number'], -4);
  }

  // Save card data
  if (!empty($card_data['card_id'])) {
    // Update
    // Load original unchanged data
    $card_data_original = commerce_cardonfile_data_load($card_data['card_id']);

    // Skip save if have card_id but card does not exist
    if (empty($card_data_original)) {
      return $return;
    }

    $card_data['changed'] = REQUEST_TIME;

    // Merge original to pass to can_delete hook
    $card_data += $card_data_original;

    // Check if can disable the card
    $disabling = empty($card_data['status']) && !empty($card_data_original['status']);
    if ($disabling && !commerce_cardonfile_data_can_delete($card_data)) {
      return FALSE;
    }

    $return = drupal_write_record('commerce_card_data', $card_data, 'card_id');

    // Notify other modules that this card data has been updated.
    rules_invoke_all('commerce_cardonfile_data_update', $card_data, $card_data_original);

    // Notify other modules that this card data has been disabled.
    if ($disabling) {
      rules_invoke_all('commerce_cardonfile_data_disable', $card_data, $card_data_original);
    }
  }
  else {
    // Insert
    $card_data['card_id'] = NULL;
    $card_data['created'] = REQUEST_TIME;
    $card_data['changed'] = REQUEST_TIME;

    // Mark as default if this is the user's first active card for this instance_id
    if (empty($card_data['instance_default']) && !empty($card_data['uid']) && !empty($card_data['instance_id'])) {
      $instance_active_cards = commerce_cardonfile_data_load_multiple($card_data['uid'], $card_data['instance_id'], TRUE);
      if (empty($instance_active_cards)) {
        $card_data['instance_default'] = 1;
      }
    }

    $return = drupal_write_record('commerce_card_data', $card_data);

    // Notify other modules that this card data has been inserted.
    rules_invoke_all('commerce_cardonfile_data_insert', $card_data);

    // Save for other to access
    _commerce_cardonfile_data_current_request_last_inserted($card_data);
  }

  // ensure that there is only 1 default per instance
  $num_cleared = commerce_cardonfile_data_ensure_single_instance_default($card_data);

  return $return;
}

/**
 * Store last inserted card data for reference by other functions
 *
 * Items are stored as a stack, ie last on top
 */
function _commerce_cardonfile_data_current_request_last_inserted($card_data = array()) {
  $stack = &drupal_static(__FUNCTION__, array());
  $stack_size = 5;

  if (!empty($card_data) && !empty($card_data['card_id'])) {
    array_unshift($stack, $card_data);
    if (count($stack) > $stack_size) {
      array_pop($stack);
    }
  }

  return $stack;
}

/**
 * Determines whether or not the give card can be deleted.
 *
 * @param $card_data
 *   The card data array to be checked for deletion.
 *
 * @return
 *   Boolean indicating whether or not the card can be deleted.
 */
function commerce_cardonfile_data_can_delete($card_data) {
  // Return FALSE if the given card does not have an ID; it need not be
  // deleted, which is functionally equivalent to cannot be deleted as far as
  // code depending on this function is concerned.
  if (empty($card_data['card_id'])) {
    return FALSE;
  }

  // If any module implementing commerce_cardonfile_data_can_delete() returns
  // FALSE the card cannot be deleted. Return TRUE if none return FALSE.
  foreach (module_implements('commerce_cardonfile_data_can_delete') as $module) {
    $function = $module . '_commerce_cardonfile_data_can_delete';
    $result = $function($card_data);
    if ($result === FALSE) {
      return FALSE;
    }
  }

  // Allow by default
  return TRUE;
}

/**
 * Deletes stored card data record by local ID.
 *
 * @param $card_id
 *   The local ID of the card data to delete.
 */
function commerce_cardonfile_data_delete($card_id) {
  $card_data = commerce_cardonfile_data_load($card_id);

  if (!empty($card_data) && commerce_cardonfile_data_can_delete($card_data)) {
    // Notify other modules that this card data has been deleted.
    rules_invoke_all('commerce_cardonfile_data_delete', $card_data);

    // Delete references for card data
    commerce_cardonfile_data_delete_references($card_data);

    // Delete card data
    db_delete('commerce_card_data')
      ->condition('card_id', $card_id)
      ->execute();
  }
}

/**
 * Deletes multiple stored card data record by local ID.
 *
 * @param $card_ids
 *   The local ID of the card data to delete.
 */
function commerce_cardonfile_data_delete_multiple($card_ids) {
  if (empty($card_ids)) {
    return;
  }

  $cards = commerce_cardonfile_data_load_multiple_by_id($card_ids);
  if (empty($cards)) {
    return;
  }

  foreach ($cards as $card_id => $card_data) {
    if (commerce_cardonfile_data_can_delete($card_data)) {
      // Notify other modules that this card data has been deleted.
      rules_invoke_all('commerce_cardonfile_data_delete', $card_data);

      // Delete references for card data
      commerce_cardonfile_data_delete_references($card_data);
    }
  }

  // Delete card data
  db_delete('commerce_card_data')
    ->condition('card_id', array_keys($cards))
    ->execute();
}

/**
 * Deletes any references to the given card data.
 */
function commerce_cardonfile_data_delete_references($card_data) {
  if (empty($card_data['card_id'])) {
    return;
  }

  // Check the data in every line item reference field.
  foreach (commerce_info_fields('commerce_cardonfile_reference') as $field_name => $field) {
    // Query for any entity referencing the deleted line item in this field.
    $query = new EntityFieldQuery();
    $query->fieldCondition($field_name, 'card_id', $card_data['card_id'], '=');
    $result = $query->execute();

    // If results were returned...
    if (!empty($result)) {
      // Loop over results for each type of entity returned.
      foreach ($result as $entity_type => $data) {
        // Load the entities of the current type.
        $entities = entity_load($entity_type, array_keys($data));

        // Loop over each entity and remove the reference to the deleted line item.
        foreach ($entities as $entity_id => $entity) {
          commerce_entity_reference_delete($entity, $field_name, 'card_id', $card_data['card_id']);

          entity_save($entity_type, $entity);
        }
      }
    }
  }
}

/**
 * Returns the UNIX timestamp for the card data expiration
 */
function commerce_cardonfile_data_expiration_timestamp($card_data) {
  if (empty($card_data['card_exp_month']) || empty($card_data['card_exp_year'])) {
    return;
  }

  $month = (int) $card_data['card_exp_month'];
  $year = (int) $card_data['card_exp_year'];

  if ($month + 1 > 12) {
    $month = 1;
    $year++;
  }
  else {
    $month++;
  }

  return gmmktime(0, 0, 0, $month, 1, $year);
}

/**
 * Returns TRUE if the card data has NOT expired
 */
function commerce_cardonfile_data_check_expiration($card_data) {
  if (!isset($card_data['card_exp_month']) || !isset($card_data['card_exp_year'])) {
    return FALSE;
  }

  return commerce_cardonfile_check_expiration($card_data['card_exp_month'], $card_data['card_exp_year']);
}

/**
 * Returns TRUE if the card can be charged
 */
function commerce_cardonfile_data_can_charge($card_data) {
  // DENY if card is disabled
  if (empty($card_data['status'])) {
    return FALSE;
  }

  // DENY if there is no payment method instance
  if (empty($card_data['instance_id'])) {
    return FALSE;
  }

  // DENY if card is expired
  if (!commerce_cardonfile_data_check_expiration($card_data)) {
    return FALSE;
  }

  // load payment method related to the card
  $payment_method = commerce_payment_method_instance_load($card_data['instance_id']);

  // DENY if not a valid payment method
  if (empty($payment_method)) {
    return FALSE;
  }

  // ALLOW/DENY based on payment method capabilities
  $callback = commerce_cardonfile_payment_method_callback($payment_method, 'process callback');
  return $callback ? TRUE : FALSE;
}

/**
 * Set a card's instance default value
 */
function commerce_cardonfile_data_set_default_card($card_id, $instance_default_value = 1) {
  if (!empty($card_id)) {
    $update_data = array(
      'card_id' => $card_id,
      'instance_default' => !empty($instance_default_value),
    );
    return commerce_cardonfile_data_save($update_data);
  }

  return FALSE;
}

/**
 * Toggle the card data's default flag
 */
function commerce_cardonfile_data_toggle_default_card($card_data) {
  if (!empty($card_data['card_id'])) {
    $current = !empty($card_data['instance_default']);
    return commerce_cardonfile_data_set_default_card($card_data['card_id'], !$current);
  }

  return FALSE;
}

/**
 * Determines if the current user has access to toggle the default card
 */
function commerce_cardonfile_data_toggle_default_card_callback_access($card_data, $owner, $token) {
  // DENY if token is invalid
  if (!commerce_cardonfile_valid_token($token)) {
    return FALSE;
  }

  // DENY if already default
  if (!empty($card_data['instance_default'])) {
    return FALSE;
  }

  return commerce_cardonfile_data_access('edit', $card_data, $owner);
}

/**
 * Returns menu path title for toggle card default
 */
function commerce_cardonfile_data_toggle_default_card_callback_title($card_data) {
  return !empty($card_data['instance_default']) ?
    t('Current Default') :
    t('Set as Default');
}

/**
 * Toggle the card data's default flag
 */
function commerce_cardonfile_data_toggle_default_card_callback($card_data, $owner, $token) {
  commerce_cardonfile_data_toggle_default_card($card_data);
  commerce_cardonfile_redirect_to_user($owner);
}

/**
 * Load the owners default cards
 *
 * @param $owner
 *   The user object of the owner
 * @param $instance_id
 *   The payment method instance id
 *
 * @return
 *   An array of data arrays indexed by card_id.
 */
function commerce_cardonfile_data_load_user_default_cards($owner_uid, $instance_id = NULL) {
  $conditions = array(
    'uid' => $owner_uid,
    'status' => 1,
    'instance_default' => 1,
  );

  if (!empty($instance_id)) {
    $conditions['instance_id'] = $instance_id;
  }

  $cards = commerce_cardonfile_data_load_multiple_by_id(array(), $conditions);
  return $cards;
}

/**
 * Ensures that there is only 1 default per user per instance_id
 *
 * @param $card_data
 *   The card data array to ensure against, usually the inserted or updated data.
 *
 * @return
 *   The number of records updated
 */
function commerce_cardonfile_data_ensure_single_instance_default($card_data) {
  if (empty($card_data['instance_default']) ||
      empty($card_data['instance_id']) ||
      empty($card_data['uid']) ||
      empty($card_data['card_id'])) {
    return 0;
  }

  $num_updated = db_update('commerce_card_data')
    ->fields(array(
      'instance_default' => 0,
    ))
    ->condition('uid', $card_data['uid'])
    ->condition('instance_id', $card_data['instance_id'])
    ->condition('card_id', $card_data['card_id'], '<>')
    ->execute();

  return $num_updated;
}


// -----------------------------------------------------------------------
// User handling

/**
 * Implements hook_user_delete()
 */
function commerce_cardonfile_user_delete($account) {
  if (empty($account->uid)) {
    return;
  }

  $cards = commerce_cardonfile_data_load_multiple_by_id(array(), array('uid' => $account->uid));
  if (empty($cards)) {
    return;
  }

  commerce_cardonfile_data_delete_multiple(array_keys($cards));
}

// -----------------------------------------------------------------------
// Order handling

/**
 * Define property info for line item Kiala Point records
 */
function commerce_cardonfile_order_process_card_response_property_info_callback() {
  return array(
    'status' => array(
      'label' => t('Status'),
      'type' => 'boolean',
    ),
    'code' => array(
      'label' => t('Status Code'),
      'type' => 'text',
      'options list' => 'commerce_cardonfile_order_process_card_status_code_options',
    ),
    'error_level' => array(
      'label' => t('Error Level'),
      'type' => 'integer',
      'options list' => 'commerce_cardonfile_order_process_card_error_level_options',
      'getter callback' => 'commerce_cardonfile_order_process_card_get_properties',
      'computed' => TRUE,
    ),
    'message' => array(
      'label' => t('Message'),
      'description' => t('Message for the process response.'),
      'type' => 'text',
      'getter callback' => 'commerce_cardonfile_order_process_card_get_properties',
      'computed' => TRUE,
    ),
    'card_chosen' => array(
      'label' => t('Card Chosen'),
      'type' => 'struct',
      'property info' => commerce_cardonfile_data_property_info_callback(),
    ),
  );
}

/**
 * Returns an options list of processing card response status codes
 */
function commerce_cardonfile_order_process_card_status_code_options() {
  return array(
    COMMERCE_COF_PROCESS_CODE_INSUFFICIENT_DATA => t('Insufficient data'),
    COMMERCE_COF_PROCESS_CODE_CARD_NA => t('No card available'),
    COMMERCE_COF_PROCESS_CODE_CARD_EXPIRED => t('Card expired'),
    COMMERCE_COF_PROCESS_CODE_CARD_NOT_CHARGEABLE => t('Card not chargeable'),
    COMMERCE_COF_PROCESS_CODE_METHOD_EMPTY => t('Payment method not valid'),
    COMMERCE_COF_PROCESS_CODE_METHOD_NOT_CAPABLE => t('Payment method not capable'),
    COMMERCE_COF_PROCESS_CODE_METHOD_FAILURE => t('Payment method failure'),
    COMMERCE_COF_PROCESS_CODE_METHOD_SUCCESS => t('Payment method success'),
  );
}

/**
 * Returns an option list of processing card response error level
 */
function commerce_cardonfile_order_process_card_error_level_options() {
  return array(
    0 => t('Notice'),
    1 => t('Warning'),
    2 => t('Error'),
  );
}

/**
 * Callback for getting payment transaction properties.
 */
function commerce_cardonfile_order_process_card_get_properties($data, array $options, $name) {
  switch ($name) {
    case 'message':
      if (!empty($data['message'])) {
        $message_variables = array();
        if (!empty($data['message_variables']) && is_array($data['message_variables'])) {
          $message_variables = $data['message_variables'];
        }
        return t($data['message'], $message_variables);
      }
      else {
        return '';
      }

    case 'error_level':
      return commerce_cardonfile_order_process_card_error_level($data);
  }
}

/**
 * Returns the error level for a given card processing response array
 */
function commerce_cardonfile_order_process_card_error_level($response) {
  if (empty($response['code'])) {
    return 0;
  }

  $level = 0;
  switch ($response['code']) {
    case COMMERCE_COF_PROCESS_CODE_METHOD_EMPTY:
    case COMMERCE_COF_PROCESS_CODE_METHOD_NOT_CAPABLE:
      $level = 1;
      break;

    case COMMERCE_COF_PROCESS_CODE_CARD_EXPIRED:
    case COMMERCE_COF_PROCESS_CODE_CARD_NOT_CHARGEABLE:
    case COMMERCE_COF_PROCESS_CODE_METHOD_FAILURE:
    case COMMERCE_COF_PROCESS_CODE_METHOD_SUCCESS:
      $level = 2;
      break;
  }

  return $level;
}

/**
 * Process a charge for a given an order
 *
 * Wrapper function for _commerce_cardonfile_order_invoke_process_card() to
 * trigger rules events
 *
 * @param $order
 *   An order object
 * @param $charge
 *   Charge array of amount, currency_code
 * @param $card_data
 *   The card data array. If not provided, then the chargeable card for the
 *   order will be determined.
 *
 * @return
 *   TRUE if the order was processed successfully
 */
function commerce_cardonfile_order_process_card($order, $charge = array(), $card_data = array()) {
  $response = _commerce_cardonfile_order_invoke_process_card($order, $charge, $card_data);
  $card_chosen = array();
  if (!empty($response['card_chosen'])) {
    $card_chosen = $response['card_chosen'];
  }
  elseif (!empty($card_data)) {
    $card_chosen = $card_data;
  }

  if (empty($response) || empty($response['status'])) {
    rules_invoke_all('commerce_cardonfile_order_process_failed', $card_chosen, $order, $charge, $response);
  }
  else {
    rules_invoke_all('commerce_cardonfile_order_process_success', $card_chosen, $order, $charge, $response);
  }

  return $response;
}

/**
 * Invoke the payment method callback to process a charge for a given an order
 *
 * @param $order
 *   An order object
 * @param $charge
 *   Charge array of amount, currency_code
 * @param $card_data
 *   The card data array. If not provided, then the chargeable card for the
 *   order will be determined.
 *
 * @return
 *   TRUE if the order was processed successfully
 */
function _commerce_cardonfile_order_invoke_process_card($order, $charge = array(), $card_data = array()) {
  $response = array(
    'status' => FALSE,
    'code' => COMMERCE_COF_PROCESS_CODE_INSUFFICIENT_DATA,
    'message' => '',
    'message_variables' => array(),
  );

  // Exit if no order id
  if (empty($order->order_id)) {
    $response['message'] = 'Order ID is not provided.';
    return $response;
  }

  $response['message_variables'] += array(
    '@order_id' => $order->order_id,
  );

  // Exit if no user associated with the order
  if (empty($order->uid)) {
    $response['message'] = 'Order owner not provided for order @order_id.';
    return $response;
  }
  $response['message_variables'] += array(
    '@uid' => $order->uid,
  );

  // Wrap up the order
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // determine charge amount
  // set charge to order balance if none provided
  if (empty($charge)) {
    $charge = commerce_payment_order_balance($order);
  }

  // exit if no charge
  if (empty($charge) || empty($charge['amount']) || empty($charge['currency_code'])) {
    $response['message'] = 'Charge amount not provided for order @order_id.';
    return $response;
  }

  $response['message_variables'] += array(
    '@charge' => commerce_currency_format($charge['amount'], $charge['currency_code']),
  );

  // Determine order's chargeable card
  if (!empty($card_data)) {
    // A specific card is provided ...
    $response['card_chosen'] = $card_data;

    if (!commerce_cardonfile_order_can_charge_card($order, $card_data)) {
      // check for expiration to set a specific code
      if (!commerce_cardonfile_data_check_expiration($card_data)) {
        $response['code'] = COMMERCE_COF_PROCESS_CODE_CARD_EXPIRED;
        $response['message'] = 'Card on file has expired for user @uid\'s card @card_id when attempting to process @order_id.';
      }
      else {
        $response['code'] = COMMERCE_COF_PROCESS_CODE_CARD_NOT_CHARGEABLE;
        $response['message'] = 'Card provided cannot be charged for the order @order_id and user @uid.';
      }

      return $response;
    }
  }
  elseif ($possible_cards = _commerce_cardonfile_invoke_order_chargeable_cards($order)) {
    // Determine any chargeable cards ...
    $card_data = array();
    $unchargeable_cards = array();
    foreach ($possible_cards as $card_id => $possible_card) {
      if (commerce_cardonfile_order_can_charge_card($order, $possible_card)) {
        $card_data = $possible_card;
        break;
      }
      else {
        $unchargeable_cards[$card_id] = $possible_card;
      }
    }

    if (empty($card_data)) {
      $response['code'] = COMMERCE_COF_PROCESS_CODE_CARD_NA;
      $response['message'] = 'No chargeable card on file is available for the order @order_id and user @uid.';

      if (!empty($unchargeable_cards)) {
        // check first unchargeable card for expiration
        $unchargeable_card_top = reset($unchargeable_cards);
        $response['card_chosen'] = $unchargeable_card_top;
        if (!commerce_cardonfile_data_check_expiration($unchargeable_card_top)) {
          $response['code'] = COMMERCE_COF_PROCESS_CODE_CARD_EXPIRED;
          $response['message'] = 'Card on file has expired for user @uid\'s card @card_id when attempting to process @order_id.';
        }
      }

      return $response;
    }

    $response['card_chosen'] = $card_data;
  }

  if (empty($response['card_chosen'])) {
    $response['card_chosen'] = $card_data;
  }

  // update tokens with card data
  $response['message_variables'] += _commerce_cardonfile_data_card_replacements($card_data, '@');

  // load payment method
  $payment_method = commerce_payment_method_instance_load($card_data['instance_id']);
  if (empty($payment_method)) {
    $response['code'] = COMMERCE_COF_PROCESS_CODE_METHOD_EMPTY;
    $response['message'] = 'The payment method instance (@instance_id) is not available on the system.';
    return $response;
  }

  $response['message_variables'] += array(
    '@method' => isset($payment_method['short_title']) ? $payment_method['short_title'] : $payment_method['method_id'],
  );

  // determine payment method's callback function
  $func = commerce_cardonfile_payment_method_callback($payment_method, 'process callback');

  // Exit if no callback - sanity check since it should have this if "can charge"
  if (empty($func)) {
    $response['code'] = COMMERCE_COF_PROCESS_CODE_METHOD_NOT_CAPABLE;
    $response['message'] = 'The payment method @method instance (@instance_id) does not implement a valid card on file "process callback".';
    return $response;
  }

  // invoke callback function
  $method_return = $func($payment_method, $card_data, $order, $charge);

  // process return from gateway module
  if ($method_return === FALSE) {
    // Failure
    $response['status'] = FALSE;
    $response['code'] = COMMERCE_COF_PROCESS_CODE_METHOD_FAILURE;
    $response['message'] = 'The payment method @method instance (@instance_id) failed for order @order_id, user @uid, card @card_id, charge amount @charge.';
  }
  else {
    // Success
    $response['status'] = TRUE;
    $response['code'] = COMMERCE_COF_PROCESS_CODE_METHOD_SUCCESS;
    $response['message'] = 'The payment method  @method instance (@instance_id) was successful for order @order_id, user @uid, card @card_id, charge amount @charge.';

    // load a fresh order in case it was modified during method callback
    $order = commerce_order_load($order->order_id);
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

    // Store the last processed card on the order card reference field
    if (isset($order_wrapper->commerce_cardonfile)) {
      $order_ref_card_id = $order_wrapper->commerce_cardonfile->value();
      if (empty($order_ref_card_id) || $order_ref_card_id != $card_data['card_id']) {
        $order_wrapper->commerce_cardonfile = array('card_id' => $card_data['card_id']);
        $order_wrapper->save();
      }
    }
  }

  return $response;
}

/**
 * Order properties getter callback
 */
function commerce_cardonfile_order_property_get($entity, array $options, $name) {
  // Exit if no order owner
  if (empty($entity->uid)) {
    return;
  }

  switch ($name) {
    case 'chargeable_cards':
      $cards = _commerce_cardonfile_order_chargeable_cards($entity);
      return !empty($cards) ? $cards : NULL;

    case 'chargeable_card_preferred':
      $cards = _commerce_cardonfile_order_chargeable_cards($entity);
      return !empty($cards) ? reset($cards) : NULL;
  }
}

/**
 * Returns TRUE if the card can be charged for the given order
 */
function commerce_cardonfile_order_can_charge_card($order, $card_data) {
  // DENY if no order id
  if (empty($order->order_id)) {
    return FALSE;
  }

  // DENY if no owner provided
  if (empty($order->uid) || empty($card_data['uid'])) {
    return FALSE;
  }

  // DENY if owners do not match
  if ($card_data['uid'] != $order->uid) {
    return FALSE;
  }

  return commerce_cardonfile_data_can_charge($card_data);
}

/**
 * Returns the chargeable cards for the given order.
 *
 * @param $order
 *   An order object
 *
 * @return
 *   An associative array of card data keyed by card_id or
 *   an empty array if no cards are found
 */
function _commerce_cardonfile_order_chargeable_cards($order) {
  $possible_cards = _commerce_cardonfile_invoke_order_chargeable_cards($order);

  // Validate cards to ensure capable of charging
  foreach (array_keys($possible_cards) as $card_id) {
    if (!commerce_cardonfile_order_can_charge_card($order, $possible_cards[$card_id])) {
      unset($possible_cards[$card_id]);
    }
  }

  return $possible_cards;
}

/**
 * Invokes and returns the chargeable cards for the given order.
 *
 * hook_commerce_cardonfile_order_chargeable_cards()
 *
 * @param $order
 *   An order object
 *
 * @return
 *   An associative array of card data keyed by card_id or
 *   an empty array if no cards are found
 */
function _commerce_cardonfile_invoke_order_chargeable_cards($order) {
  if (empty($order->uid)) {
    return array();
  }

  // Build possible cards
  $possible_card_ids = module_invoke_all('commerce_cardonfile_order_chargeable_cards', $order);
  drupal_alter('commerce_cardonfile_order_chargeable_cards', $possible_card_ids);

  // Exit if no possible cards
  if (empty($possible_card_ids)) {
    return array();
  }

  // Load card data
  $possible_cards = commerce_cardonfile_data_load_multiple_by_id($possible_card_ids);

  // Exit if cards invalid
  if (empty($possible_cards)) {
    return array();
  }

  // Sort per the returned hook card ids
  $return = array();
  foreach ($possible_card_ids as $card_id) {
    if (isset($possible_cards[$card_id])) {
      $return[$card_id] = $possible_cards[$card_id];
    }
  }

  return $return;
}

/**
 * Implements hook_commerce_cardonfile_order_chargeable_cards()
 */
function commerce_cardonfile_commerce_cardonfile_order_chargeable_cards($order) {
  $possible_cards = array();

  // Default card for payment instance
  if (!empty($order->data['payment_method'])) {
    $default_cards = commerce_cardonfile_data_load_user_default_cards($order->uid, $order->data['payment_method']);
    if (!empty($default_cards)) {
      $possible_cards = array_keys($default_cards);
    }
  }

  return $possible_cards;
}


// -----------------------------------------------------------------------
// Token handling

/**
 * Returns the session token for this module
 */
function commerce_cardonfile_get_token() {
  return drupal_get_token('commerce_cardonfile_70k3N');
}

/**
 * Returns TRUE if session token is valid token created by this module
 */
function commerce_cardonfile_valid_token($token) {
  return drupal_valid_token($token, 'commerce_cardonfile_70k3N');
}


// -----------------------------------------------------------------------
// Helpers

/**
 * Loads credit card helper functions in commerce_payment
 */
function commerce_cardonfile_load_credit_card_helpers() {
  static $loaded = FALSE;

  if (!$loaded) {
    $loaded = module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  }
}

/**
 * Create a billing addressfield form outside of customer profile
 *
 * @param $form
 *   The form the address field will be attached to
 * @param $form_state
 *   The form state for the form
 * @param $default_values
 *   An array of default values with addressfield parameter keys
 *
 * @return
 *   The form element array created for this field.
 *
 * @see field_default_form()
 */
function commerce_cardonfile_billing_address_form(&$form, &$form_state, $default_values = array(), $include_name_lines = FALSE) {
  $host_entity_type = 'commerce_customer_profile';
  $host_bundle = 'billing';
  $host_entity = NULL;
  $field_name = 'commerce_customer_address';
  $langcode = LANGUAGE_NONE;

  $field = field_info_field($field_name);
  $instance = field_info_instance($host_entity_type, $field_name, $host_bundle);

  // Set default values
  $values = array();
  if (!empty($default_values) && is_array($default_values)) {
    $values = $default_values;
  }

  // Merge values with addressfield defaults
  $values += addressfield_default_values();

  // Remove names
  if (empty($include_name_lines)) {
    // remove names from format handlers
    $name_format_handlers = array('name-full', 'name-oneline');
    $format_handlers = &$instance['widget']['settings']['format_handlers'];
    $format_handlers = array_diff($format_handlers, $name_format_handlers);
    unset($format_handlers);

    // remove names from values
    $name_element_keys = array('first_name', 'last_name', 'name_line');
    $values = array_diff_key($values, array_flip($name_element_keys));
  }

  // initialize parents for field_default_form
  if (!isset($form['#parents'])) {
    $form['#parents'] = array();
  }

  // build pseudo item
  $items = array($values);

  // Retrieve default form array
  return field_default_form($host_entity_type, $host_entity, $field, $instance, $langcode, $items, $form, $form_state, 0);
}

/**
 * Returns TRUE if the card has NOT expired
 */
function commerce_cardonfile_check_expiration($month, $year) {
  commerce_cardonfile_load_credit_card_helpers();
  $check = commerce_payment_validate_credit_card_exp_date($month, $year);
  return $check === TRUE;
}

/**
 * Wrapper to determine card type based on card number
 */
function _commerce_cardonfile_get_credit_card_type($number) {
  // Determine the new credit card type if possible for use in later code.
  commerce_cardonfile_load_credit_card_helpers();

  $card_type = '';
  $valid_types = array_keys(commerce_payment_credit_card_types());
  if (!empty($number)) {
    $card_type = commerce_payment_validate_credit_card_type($number, $valid_types);
  }

  return $card_type;
}

/**
 * Validates a set of credit card details entered via the credit card form.
 * Rewrite of commerce_payment_credit_card_validate() with conditional
 * card number and expiration
 *
 * @param $details
 *   An array of credit card details as retrieved from the credit card array in
 *   the form values of a form containing the credit card form.
 * @param $settings
 *   Settings used for calling validation functions and setting form errors:
 *   - form_parents: an array of parent elements identifying where the credit
 *     card form was situated in the form array
 *
 * @return
 *   TRUE or FALSE indicating the validity of all the data.
 *
 * @see commerce_payment_credit_card_form()
 */
function _commerce_cardonfile_credit_card_validate($details, $settings) {
  $prefix = implode('][', $settings['form_parents']) . '][';
  $valid = TRUE;

  // Validate the credit card type.
  if (!empty($details['valid_types'])) {
    if (isset($details['number'])) {
      $type = commerce_payment_validate_credit_card_type($details['number'], $details['valid_types']);
      if ($type === FALSE) {
        form_set_error($prefix . 'type', t('You have entered a credit card number of an unsupported card type.'));
        $valid = FALSE;
      }
      elseif ($type != $details['type']) {
        form_set_error($prefix . 'number', t('You have entered a credit card number that does not match the type selected.'));
        $valid = FALSE;
      }
    }
  }

  // Validate the credit card number.
  if (isset($details['number']) && !commerce_payment_validate_credit_card_number($details['number'])) {
    form_set_error($prefix . 'number', t('You have entered an invalid credit card number.'));
    $valid = FALSE;
  }

  // Validate the expiration date.
  if (isset($details['exp_month']) && isset($details['exp_year'])) {
    if (($invalid = commerce_payment_validate_credit_card_exp_date($details['exp_month'], $details['exp_year'])) !== TRUE) {
      form_set_error($prefix . 'exp_' . $invalid, t('You have entered an expired credit card.'));
      $valid = FALSE;
    }
  }

  // Validate the security code if present.
  if (isset($details['code']) && isset($details['number']) && !commerce_payment_validate_credit_card_security_code($details['number'], $details['code'])) {
    form_set_error($prefix . 'code', t('You have entered an invalid card security code.'));
    $valid = FALSE;
  }

  // Validate the start date if present.
  if (isset($details['start_date']) && ($invalid = commerce_payment_validate_credit_card_start_date($details['exp_month'], $details['exp_year'])) !== TRUE) {
    form_set_error($prefix . 'start_' . $invalid, t('Your have entered an invalid start date.'));
    $valid = FALSE;
  }

  // Validate the issue number if present.
  if (isset($details['issue']) && !commerce_payment_validate_credit_card_issue($details['issue'])) {
    form_set_error($prefix . 'issue', t('You have entered an invalid issue number.'));
    $valid = FALSE;
  }

  return $valid;
}
